#!/usr/bin/env php
<?php

/**
 * php vendor/packme
 * 快速打包项目代码 <br>
 * 运行于项目根目录 <br>
 * 首次运行会在当前目录下生成 dist/version.ini <br>
 * 主要是利用了git archive(归档)功能 <br>
 * 环境依赖: php>=7.4/git命令行/zippy <br>
 * @author DM <769245396@qq.com>
 */

use Alchemy\Zippy\Zippy;
use luguohuakai\func\Func;

require './vendor/autoload.php';

Func::logInfo('PACKME V1.0.0');
Func::logInfo();

$dist_dir = './dist';
if (!is_dir($dist_dir)) mkdir($dist_dir);
$version_file = './dist/version.ini';
if (!is_file($version_file)) file_put_contents($version_file, '');

class Ini
{
    private string $file;
    public array $all;

    public function __construct($file)
    {
        if (!is_file($file)) file_put_contents($file, '');
        $this->file = $file;
        $this->all = parse_ini_file($file);
    }

    public function get($key, $default = null)
    {
        if (!is_file($this->file)) return $default;
        return $this->all[$key] ?? $default;
    }

    public function set($key, $value): bool
    {
        $data = array_merge($this->all, [$key => $value]);
        return !(file_put_contents($this->file, $this->arrayToIni($data)) === false);
    }

    public function setAll($data): bool
    {
        $data = array_merge($this->all, $data);
        return !(file_put_contents($this->file, $this->arrayToIni($data)) === false);
    }

    private function arrayToIni($data): string
    {
        if (empty($data)) return '';
        $str = '';
        foreach ($data as $key => $datum) {
            $str .= "$key=$datum\r\n";
        }
        return $str;
    }
}

class Git
{
    private string $cmd_hash_short = 'git rev-list HEAD --abbrev-commit --max-count=1';
    private string $cmd_hash_long = 'git rev-parse HEAD';
    private string $cmd_branch_name = 'git symbolic-ref --short -q HEAD';
    private string $cmd_name = 'git rev-parse --show-toplevel';

    private string $output = '';
    private array $add_file = [];
    private string $format = '';
    private string $branch = '';

    private string $new_commit = '';
    private string $old_commit = '';

    // 默认打包于当前目录下的dist目录内
    private string $dist = './dist/';

    /**
     * 说明文件应该先就存在于dist<br>
     * 打包前先往说明文件追加所有变更文件路径<br>
     * 如果说明文件存在则自动打包说明文件<br>
     * @var string
     */
    private string $change_file = './dist/change.txt';

    public string $cmd = '';

    /**
     * @param string $output 输出文件名 如: update.tar.gz
     * @return $this
     */
    public function output(string $output): Git
    {
        $this->output = $output;
        return $this;
    }

    public function getOutPutFile(): string
    {
        return $this->dist . $this->output;
    }

    /**
     * 需要额外打包的文件 可添加多个
     * @param string $add_file 当前路径下的文件全路径 如: data/demo.sql
     * @return $this
     */
    public function addFile(string $add_file): Git
    {
        $this->add_file = array_merge($this->add_file, [$add_file]);
        return $this;
    }

    /**
     * 指定打包文件格式
     * 如果output已指定文件后缀这里可以不再指定
     * @param string $format 如: tar zip tar.gz
     * @return $this
     */
    public function format(string $format): Git
    {
        $this->format = $format;
        return $this;
    }

    /**
     * 指定最新的一次git提交的hash或HEAD(将包含)
     * @param $commit_id
     * @return $this
     */
    public function newCommit($commit_id): Git
    {
        $this->new_commit = $commit_id;
        return $this;
    }

    /**
     * 指定最之前一次git提交的hash或HEAD(将不包含)
     * @param $commit_id
     * @return $this
     */
    public function oldCommit($commit_id): Git
    {
        $this->old_commit = $commit_id;
        return $this;
    }

    /**
     * 全量打包时的分支名称
     * @param $branch_name
     * @return $this
     */
    public function branch($branch_name): Git
    {
        $this->branch = $branch_name;
        return $this;
    }

    public function prepare(): Git
    {
        $this->cmd .= 'git archive ';
        if ($this->branch) $this->cmd .= "$this->branch ";
        if ($this->output) $this->cmd .= "-o $this->dist$this->output ";
        if ($this->format) $this->cmd .= "--format=$this->format ";
        if (!empty($this->add_file)) {
            foreach ($this->add_file as $item) {
                $this->cmd .= "--add-file=$item ";
            }
        }
        if ($this->new_commit) {
            $this->cmd .= "$this->new_commit ";
            $this->prepareDiff();
        }
        $this->cmd = trim($this->cmd);
        return $this;
    }

    private function prepareDiff()
    {
        $diff = 'git diff --name-only %s %s';

        if (($this->new_commit === 'NOW' && !$this->old_commit)) {
            $diff = sprintf($diff, 'HEAD', '');
        } elseif (($this->new_commit === 'NOW' && $this->old_commit === 'HEAD^')) {
            $diff = sprintf($diff, 'HEAD^', '');
        } else {
            $diff = sprintf($diff, $this->old_commit, $this->new_commit);
        }
        $diff = trim($diff);

//        if (PHP_OS === 'WINNT') {
//            // todo: widows下怎么写?
////            $this->cmd = "set output=\nfor /f \"delims=\" %%a in ('$diff') do ( set output=!output!\"%%a\" )\n$this->cmd %output%";
//            $this->cmd .= "$($diff)";
//        } else {
//            $this->cmd .= "$($diff)";
//        }

        if (is_file($this->change_file)) {
            file_put_contents($this->change_file, PHP_EOL . 'Change Files:' . PHP_EOL, FILE_APPEND);
            file_put_contents($this->change_file, $this->execGit($diff) . PHP_EOL, FILE_APPEND);
        }

        $this->cmd .= "$($diff)";
    }

    public function run(): string
    {
        if (file_exists($this->change_file)) $this->addFile($this->change_file);
        if (!$this->cmd) $this->prepare();
        if (PHP_OS === 'WINNT' && !$this->branch) {
            Func::logError('Windows temporarily does not support, Please execute manually');
            Func::logPrimary($this->cmd);
            return '';
        }
        if (is_file($this->getOutPutFile())) unlink($this->getOutPutFile());
        return $this->execGit($this->cmd);
    }

    public function hashShort(): string
    {
        return $this->execGit($this->cmd_hash_short);
    }

    public function hashLong(): string
    {
        return $this->execGit($this->cmd_hash_long);
    }

    public function branchName(): string
    {
        return $this->execGit($this->cmd_branch_name);
    }

    public function objectName()
    {
        $rs = $this->execGit($this->cmd_name);
        $arr = explode('/', $rs);
        return $arr[count($arr) - 1];
    }

    public function execGit($cmd): string
    {
        return trim(shell_exec("$cmd 2>&1"));
    }
}

$git = new Git;
$replaceme = './vendor/luguohuakai/packme/replaceme';
if (is_file($replaceme)) $git->addFile($replaceme);

$object_name = strtoupper($git->objectName());
$add_other_file = false;

// 打包方式 1:全量打包(默认) 2:最近一次提交和当前未提交的文件 3:某两次提交的差异文件 4:当前已修改但未提交的文件
Func::logInfo('Please select packaging method:');
Func::logInfo('      [1]: Full packaging');
Func::logInfo('      [2]: Package Last commit and current Not commit files');
Func::logInfo('      [3]: Package Two commits different files');
Func::logInfo('      [4]: Package Current Not commit files');
Func::logInfo('      [5]: Package Last commit files');
Func::logInfo('      [6]: Package the last two commit files');
Func::logPrimary('Your choice (default [1]):', false);
choice:
$choice = trim(fgets(STDIN));
$time = date('md');
$last_hash = strtoupper($git->hashShort());
switch ($choice) {
    case 2:
        $file = "{$object_name}_LAST_COMMIT_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('NOW')->oldCommit('HEAD^')->run();
        if ($rs) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $file);
        }
        exit(0);
    case 5:
        $file = "{$object_name}_LAST_COMMIT1_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('HEAD')->oldCommit('HEAD^')->run();
        if ($rs) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $file);
        }
        exit(0);
    case 6:
        $file = "{$object_name}_LAST_COMMIT2_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('HEAD')->oldCommit('HEAD^^')->run();
        if ($rs) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $file);
        }
        exit(0);
    case 4:
        $file = "{$object_name}_LAST_UPDATE_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('NOW')->run();
        if ($rs) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $file);
        }
        exit(0);
    case 3:
        Func::logInfo('Please enter new commit id:', false);
        $new = trim(fgets(STDIN));
        $_new = strtoupper($new);
        Func::logInfo('Please enter old commit id:', false);
        $old = trim(fgets(STDIN));
        $_old = strtoupper($old);
        $file = "{$object_name}_UPDATE_{$time}_{$_new}_$_old.tar.gz";
        $rs = $git->output($file)->newCommit($new)->oldCommit($old)->run();
        if ($rs) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $file);
        }
        exit(0);
    case 1:
    case '':
        break;
    default:
        Func::logError('Your input is incorrect, please re-enter');
        goto choice;
}

$ini = new Ini(dirname(__FILE__) . '/dist/version.ini');

if ($ini->get('version')) {
    $arr = explode('.', $ini->get('version'));
    $vv = "$arr[0].$arr[1].";
} else {
    $vv = 'V1.0.';
}

// 注意: 如需更改大版本 如: V1.0 -> V2.1 需手动更改./dist/version.ini中version字段大版本
$version = [
    'author' => 'DM',
    'version' => $vv . date('md') . '.' . strtoupper($git->hashShort()),
    'git_branch_name' => $git->branchName(),
    'git_version_hash_short' => $git->hashShort(),
    'git_version_hash_long' => $git->hashLong(),
    'update_time' => date('Y-m-d H:i:s'),
];

Func::logInfo('Generate version...');
Func::logInfo("Branch: {$version['git_branch_name']}");
Func::logInfo("Version: {$version['version']}\r\n");

$ini->setAll($version);

Func::logPrimary('Packing vendor? (It will take a long time for y) (y/n) (default:n): ', false);
$answer = trim(fgets(STDIN));

Func::logInfo("Begin packing...");

if ($answer == 'y') {
    $rs = $git->branch($git->branchName())->output("$object_name.{$version['version']}.tar")->addFile($version_file)->run();
    Func::logInfo($rs);
    $pack_file = $git->getOutPutFile();
    $zippy = Zippy::load();
    Func::logInfo("Begin packing vendor...");
    $archive = $zippy->open($pack_file);
    $archive->addMembers('vendor');
    $new_pack_file = $pack_file . '.gz';
    $zippy->create($new_pack_file, $pack_file);
    unlink($pack_file);
    Func::logInfo('Packing vendor finished');
} else {
    $rs = $git->branch($git->branchName())->output("$object_name.{$version['version']}.tar.gz")->addFile($version_file)->run();
    Func::logInfo($rs);
    $new_pack_file = $git->getOutPutFile();
}

Func::logInfo("Packing finished");

Func::logPrimary('Generated File: ' . $new_pack_file);
