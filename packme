#!/usr/bin/env php
<?php

/**
 * php vendor/luguohuakai/packme/packme
 * 快速打包项目代码 <br>
 * 运行于项目根目录 <br>
 * 首次运行会在当前目录下生成 dist/version.ini <br>
 * 主要是利用了git archive(归档)功能 <br>
 * 环境依赖: php>=7.4/git命令行/zippy <br>
 * @author DM <769245396@qq.com>
 */

use Alchemy\Zippy\Zippy;
use luguohuakai\func\Func;

require './vendor/autoload.php';

Func::logInfo('PACKME V1.0');
Func::logInfo();

$dist_dir = './dist';
if (!is_dir($dist_dir)) mkdir($dist_dir);
$version_file = './dist/version.ini';
if (!is_file($version_file)) file_put_contents($version_file, '');

class Ini
{
    private string $file;
    public array $all;

    public function __construct($file)
    {
        if (!is_file($file)) file_put_contents($file, '');
        $this->file = $file;
        $this->all = parse_ini_file($file);
    }

    public function get($key, $default = null)
    {
        if (!is_file($this->file)) return $default;
        return $this->all[$key] ?? $default;
    }

    public function set($key, $value): bool
    {
        $data = array_merge($this->all, [$key => $value]);
        return !(file_put_contents($this->file, $this->arrayToIni($data)) === false);
    }

    public function setAll($data): bool
    {
        $data = array_merge($this->all, $data);
        return !(file_put_contents($this->file, $this->arrayToIni($data)) === false);
    }

    private function arrayToIni($data): string
    {
        if (empty($data)) return '';
        $str = '';
        foreach ($data as $key => $datum) {
            $str .= "$key=$datum\r\n";
        }
        return $str;
    }
}

class Git
{
    private string $cmd_hash_short = 'git rev-list HEAD --abbrev-commit --max-count=1';
    private string $cmd_hash_long = 'git rev-parse HEAD';
    private string $cmd_branch_name = 'git symbolic-ref --short -q HEAD';
    private string $cmd_name = 'git rev-parse --show-toplevel';
    private string $cmd_remote_v = 'git remote -v';

    private string $output = '';
    private array $add_file = [];
    private string $format = '';
    private string $branch = '';

    private string $new_commit = '';
    private string $old_commit = '';

    // 默认打包于当前目录下的dist目录内
    private string $dist = './dist/';

    /**
     * 说明文件应该先就存在于dist<br>
     * 打包前先往说明文件追加所有变更文件路径<br>
     * 如果说明文件存在则自动打包说明文件<br>
     * @var string
     */
    private string $change_file = './dist/change.txt';

    public string $cmd = '';

    /**
     * @param string $output 输出文件名 如: update.tar.gz
     * @return $this
     */
    public function output(string $output): Git
    {
        $this->output = $output;
        return $this;
    }

    public function getOutPutFile(): string
    {
        return $this->dist . $this->output;
    }

    /**
     * 需要额外打包的文件 可添加多个
     * @param string $add_file 当前路径下的文件全路径 如: data/demo.sql
     * @return $this
     */
    public function addFile(string $add_file): Git
    {
        $this->add_file = array_merge($this->add_file, [$add_file]);
        return $this;
    }

    /**
     * 指定打包文件格式
     * 如果output已指定文件后缀这里可以不再指定
     * @param string $format 如: tar zip tar.gz
     * @return $this
     */
    public function format(string $format): Git
    {
        $this->format = $format;
        return $this;
    }

    /**
     * 指定最新的一次git提交的hash或HEAD(将包含)
     * @param $commit_id
     * @return $this
     */
    public function newCommit($commit_id): Git
    {
        $this->new_commit = $commit_id;
        return $this;
    }

    /**
     * 指定最之前一次git提交的hash或HEAD(将不包含)
     * @param $commit_id
     * @return $this
     */
    public function oldCommit($commit_id): Git
    {
        $this->old_commit = $commit_id;
        return $this;
    }

    /**
     * 全量打包时的分支名称
     * @param $branch_name
     * @return $this
     */
    public function branch($branch_name): Git
    {
        $this->branch = $branch_name;
        return $this;
    }

    public function prepare(): Git
    {
        $this->cmd .= 'git archive ';
        if ($this->branch) $this->cmd .= "$this->branch ";
        if ($this->output) $this->cmd .= "-o $this->dist$this->output ";
        if ($this->format) $this->cmd .= "--format=$this->format ";
        if (!empty($this->add_file)) {
            foreach ($this->add_file as $item) {
                $this->cmd .= "--add-file=$item ";
            }
        }
        if ($this->new_commit) {
            $this->cmd .= "$this->new_commit ";
            $this->prepareDiff();
        }
        $this->cmd = trim($this->cmd);
        return $this;
    }

    // TODO: 需要排除已删除的文件, 否则会打包失败: fatal: pathspec 'xxx' did not match any files
    private function prepareDiff()
    {
        $diff = 'git diff --name-only %s %s';

        if ($this->new_commit === 'NOW' && !$this->old_commit) {
            $diff = sprintf($diff, 'HEAD', '');
        } elseif ($this->new_commit === 'NOW' && $this->old_commit === 'HEAD~1') {
            $diff = sprintf($diff, 'HEAD~1', '');
        } else {
            $diff = sprintf($diff, $this->old_commit, $this->new_commit);
        }
        $diff = trim($diff);

        $this->cmd .= "$($diff)";

        $log = 'git log %s..%s --pretty=format:"%%B%%nChange Files" --name-only --no-merges';
        if (is_file($this->change_file)) {
            $this->clearChangeFile();
            if ($this->new_commit === 'NOW' && !$this->old_commit) {
                file_put_contents($this->change_file, PHP_EOL . 'Change Files:' . PHP_EOL, FILE_APPEND);
                shell_exec("$diff 2>&1 >> $this->change_file");
            } elseif ($this->new_commit === 'NOW' && $this->old_commit === 'HEAD~1') {
                shell_exec(sprintf($log, 'HEAD~1', 'HEAD') . " 2>&1 >> $this->change_file");
            } else {
                shell_exec(sprintf($log, $this->old_commit, $this->new_commit) . " 2>&1 >> $this->change_file");
            }
        }
    }

    /**
     * 清理历史记录
     * @return void
     */
    private function clearChangeFile()
    {
        $contents = file_get_contents($this->change_file);
        $separator = '====================';
        if ($contents) {
            $arr = explode($separator, $contents);
            if (count($arr) >= 2) {
                file_put_contents($this->change_file, $arr[0] . $separator . PHP_EOL . PHP_EOL);
            }
        } else {
            file_put_contents($this->change_file, $separator . PHP_EOL . PHP_EOL);
        }
    }

    public function run(): ?string
    {
        if (file_exists($this->change_file)) $this->addFile($this->change_file);
        if (!$this->cmd) $this->prepare();
        if (PHP_OS === 'WINNT' && !$this->branch) {
            $ps = $this->execGit('where powershell');
            if ($ps) {
                $this->cmd = "$ps $this->cmd";
            } else {
                Func::logError('Cmd temporarily does not support, Please execute manually in powershell');
                Func::logPrimary($this->cmd);
                return '';
            }
        }
        if (is_file($this->getOutPutFile())) unlink($this->getOutPutFile());
        return $this->execGit($this->cmd);
    }

    public function hashShort(): string
    {
        return $this->execGit($this->cmd_hash_short);
    }

    public function hashLong(): string
    {
        return $this->execGit($this->cmd_hash_long);
    }

    public function branchName(): string
    {
        return $this->execGit($this->cmd_branch_name);
    }

    public function objectName(): string
    {
        $res = trim($this->execGit($this->cmd_remote_v));
        if ($res) {
            $arr1 = explode(PHP_EOL, $res);
            if (isset($arr1[0]) && Func::hasSuffix(trim($arr1[0]), ')')) {
                $str = substr(trim($arr1[0]), strrpos(trim($arr1[0]), '/') + 1, strrpos(trim($arr1[0]), '.') - strrpos(trim($arr1[0]), '/') - 1);
                if ($str) $object_name = $str;
            }
        }

        if (!isset($object_name)) {
            $rs = $this->execGit($this->cmd_name);
            $arr = explode('/', $rs);
            $object_name = $arr[count($arr) - 1];
        }

        return $object_name;
    }

    /**
     * @param $cmd
     * @return string|null
     */
    public function execGit($cmd): ?string
    {
//        $rs = shell_exec("$cmd 2>&1");
        $last_line = exec($cmd, $output, $code);
        if ($code === 0) {
            if (count($output) === 1) return trim($last_line);
            if (count($output) === 0) return '';
            $str = '';
            foreach ($output as $item) {
                $str .= $item . PHP_EOL;
            }
            return trim($str);
        }
        return null;
    }
}

$git = new Git;
$replaceme = './vendor/luguohuakai/packme/replaceme';
if (is_file($replaceme)) $git->addFile($replaceme);

$object_name = strtoupper($git->objectName());
// : 自动判断当前项目根目录并生成replaceme.ini文件
$replaceme_ini = './replaceme.ini';
switch ($object_name) {
    case strtoupper('srun4-selfservice'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun4-selfservice/');
        break;
    case strtoupper('srun4-api'):
    case strtoupper('srun4-api-74'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun4-api/');
        break;
    case strtoupper('srun4k-managent'):
    case strtoupper('srun4-mgr'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun4-mgr/');
        break;
    case strtoupper('srun4-system'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun4-system/');
        break;
    case strtoupper('srunDIY'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srunDIY/');
        break;
    case strtoupper('srun4-webcron'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun4-webcron/');
        break;
    case strtoupper('srun_loginweb'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun_loginweb/');
        break;
    case strtoupper('srun4-idevm'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun4-idevm/');
        break;
    case strtoupper('srun4-idevm-selfservice'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun4-idevm-selfservice/');
        break;
    case strtoupper('srun_devmgrt'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun_devmgrt/');
        break;
    case strtoupper('srunlogweb'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srunlogweb/');
        break;
    case strtoupper('srunweixin'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srunweixin/');
        break;
    case strtoupper('webauthn'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/webauthn/');
        break;
    case strtoupper('wifi_portal'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/wifi_portal/');
        break;
    case strtoupper('srun_service'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun_service/');
        break;
    case strtoupper('srun4k-report'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun4k-report/');
        break;
    case strtoupper('srun4-bi-server'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun4-bi-server/');
        break;
    case strtoupper('MicroDraw'):
        file_put_contents($replaceme_ini, 'object_root=/srun3/www/srun_mq/');
        break;
}
if (is_file($replaceme_ini)) $git->addFile($replaceme_ini);

// 打包方式 1:全量打包(默认) 2:最近一次提交和当前未提交的文件 3:某两次提交的差异文件 4:当前已修改但未提交的文件
Func::logInfo('Please select packaging method:');
Func::logInfo('      [1]: Full packaging');
Func::logInfo('      [2]: Package Last commit and current Not commit files');
Func::logInfo('      [3]: Package Two commits different files');
Func::logInfo('      [4]: Package Current Not commit files');
Func::logInfo('      [5]: Package Last commit files');
Func::logInfo('      [6]: Package the last two commit files');
Func::logPrimary('Your choice (default [1]):', false);
choice:
$choice = trim(fgets(STDIN));
$time = date('mdy');
$last_hash = strtoupper($git->hashShort());
switch ($choice) {
    case 2:
        $file = "{$object_name}_LAST_COMMIT_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('NOW')->oldCommit('HEAD~1')->run();
        if ($rs !== null) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $git->getOutPutFile());
        }
        exit(0);
    case 5:
        $file = "{$object_name}_LAST_COMMIT1_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('HEAD')->oldCommit('HEAD~1')->run();
        if ($rs !== null) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $git->getOutPutFile());
        }
        exit(0);
    case 6:
        $file = "{$object_name}_LAST_COMMIT2_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('HEAD')->oldCommit('HEAD~2')->run();
        if ($rs !== null) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $git->getOutPutFile());
        }
        exit(0);
    case 4:
        $file = "{$object_name}_LAST_UPDATE_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('NOW')->run();
        if ($rs !== null) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $git->getOutPutFile());
        }
        exit(0);
    case 3:
        Func::logInfo('Please enter new commit id:', false);
        $new = trim(fgets(STDIN));
        $_new = strtoupper($new);
        Func::logInfo('Please enter old commit id:', false);
        $old = trim(fgets(STDIN));
        $_old = strtoupper($old);
        $file = "{$object_name}_UPDATE_{$time}_{$_new}_$_old.tar.gz";
        $rs = $git->output($file)->newCommit($new)->oldCommit($old)->run();
        if ($rs !== null) {
            Func::logInfo($rs);
            Func::logPrimary('Generated File: ' . $git->getOutPutFile());
        }
        exit(0);
    case 1:
    case '':
        break;
    default:
        Func::logError('Your input is incorrect, please re-enter');
        goto choice;
}

$ini = new Ini('./dist/version.ini');

if ($ini->get('version')) {
    $arr = explode('.', $ini->get('version'));
    $vv = "$arr[0].$arr[1].";
} else {
    $vv = 'V1.0.';
}

// 注意: 如需更改大版本 如: V1.0 -> V2.1 需手动更改./dist/version.ini中version字段大版本
$version = [
    'author' => 'DM',
    'version' => $vv . $time . '.' . strtoupper($git->hashShort()),
    'git_branch_name' => $git->branchName(),
    'git_version_hash_short' => $git->hashShort(),
    'git_version_hash_long' => $git->hashLong(),
    'update_time' => date('Y-m-d H:i:s'),
];

Func::logInfo('Generate version...');
Func::logInfo("Branch: {$version['git_branch_name']}");
Func::logInfo("Version: {$version['version']}\r\n");

$ini->setAll($version);

Func::logPrimary('Packing vendor? (It will take a long time for y) (y/n) (default:n): ', false);
$answer = trim(fgets(STDIN));

Func::logInfo("Begin packing...");

if ($answer == 'y') {
    $rs = $git->branch($git->branchName())->output("$object_name.{$version['version']}.tar")->addFile($version_file)->run();
    if ($rs !== null) {
        Func::logInfo($rs);
    } else {
        Func::logError('command exec failed: ' . $git->cmd);
    }
    $pack_file = $git->getOutPutFile();
    $zippy = Zippy::load();
    Func::logInfo("Begin packing vendor...");
    $archive = $zippy->open($pack_file);
    $archive->addMembers('vendor');
    $new_pack_file = $pack_file . '.gz';
    $zippy->create($new_pack_file, $pack_file);
    unlink($pack_file);
    Func::logInfo('Packing vendor finished');
} else {
    $rs = $git->branch($git->branchName())->output("$object_name.{$version['version']}.tar.gz")->addFile($version_file)->run();
    if ($rs !== null) {
        Func::logInfo($rs);
    } else {
        Func::logError('command exec failed: ' . $git->cmd);
        exit(1);
    }
    $new_pack_file = $git->getOutPutFile();
}

Func::logInfo("Packing finished");

Func::logPrimary('Generated File: ' . $new_pack_file);
