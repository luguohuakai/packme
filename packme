#!/usr/bin/env php
<?php

/**
 * php vendor/packme
 * 快速打包项目代码 <br>
 * 运行于项目根目录 <br>
 * 首次运行会在当前目录下生成 dist/version.ini <br>
 * 主要是利用了git archive(归档)功能 <br>
 * 环境依赖: php>=7.4/git命令行/zippy <br>
 * @author DM <769245396@qq.com>
 */

use Alchemy\Zippy\Zippy;

require './vendor/autoload.php';

/**
 * log info
 * @param string $msg
 * @param bool $wrap 是否换行
 * @return void
 */
function logI(string $msg = '', bool $wrap = true)
{
    if ($wrap) $msg .= PHP_EOL;
    echo $msg;
}

/**
 * log primary
 * @param string $msg
 * @param bool $wrap 是否换行
 * @return void
 */
function logP(string $msg = '', bool $wrap = true)
{
    $msg = "\033[34m $msg \033[0m";
    if ($wrap) $msg .= PHP_EOL;
    echo $msg;
}

/**
 * log error
 * @param string $msg
 * @param bool $wrap 是否换行
 * @return void
 */
function logE(string $msg = '', bool $wrap = true)
{
    $msg = "\033[33m $msg \033[0m";
    if ($wrap) $msg .= PHP_EOL;
    echo $msg;
}

logI('PACKME V1.0.0');
logI();

$dist_dir = './dist';
if (!is_dir($dist_dir)) mkdir($dist_dir);
$version_file = './dist/version.ini';
if (!is_file($version_file)) file_put_contents($version_file, '');

class Ini
{
    private string $file;
    public array $all;

    public function __construct($file)
    {
        if (!is_file($file)) file_put_contents($file, '');
        $this->file = $file;
        $this->all = parse_ini_file($file);
    }

    public function get($key, $default = null)
    {
        if (!is_file($this->file)) return $default;
        return $this->all[$key] ?? $default;
    }

    public function set($key, $value): bool
    {
        $data = array_merge($this->all, [$key => $value]);
        return !(file_put_contents($this->file, $this->arrayToIni($data)) === false);
    }

    public function setAll($data): bool
    {
        $data = array_merge($this->all, $data);
        return !(file_put_contents($this->file, $this->arrayToIni($data)) === false);
    }

    private function arrayToIni($data): string
    {
        if (empty($data)) return '';
        $str = '';
        foreach ($data as $key => $datum) {
            $str .= "$key=$datum\r\n";
        }
        return $str;
    }
}

class Git
{
    private string $cmd_hash_short = 'git rev-list HEAD --abbrev-commit --max-count=1';
    private string $cmd_hash_long = 'git rev-parse HEAD';
    private string $cmd_branch_name = 'git symbolic-ref --short -q HEAD';
    private string $cmd_name = 'git rev-parse --show-toplevel';

    private string $output;
    private array $add_file = [];
    private string $format;
    private string $branch;

    private string $new_commit = '';
    private string $old_commit = '';

    // 默认打包于当前目录下的dist目录内
    private string $dist = './dist/';

    public string $cmd = '';

    /**
     * @param string $output 输出文件名 如: update.tar.gz
     * @return $this
     */
    public function output(string $output): Git
    {
        $this->output = $output;
        return $this;
    }

    public function getOutPutFile(): string
    {
        return $this->dist . $this->output;
    }

    /**
     * 需要额外打包的文件 可添加多个
     * @param string $add_file 当前路径下的文件全路径 如: data/demo.sql
     * @return $this
     */
    public function addFile(string $add_file): Git
    {
        $this->add_file = array_merge($this->add_file, [$add_file]);
        return $this;
    }

    /**
     * 指定打包文件格式
     * 如果output已指定文件后缀这里可以不再指定
     * @param string $format 如: tar zip tar.gz
     * @return $this
     */
    public function format(string $format): Git
    {
        $this->format = $format;
        return $this;
    }

    /**
     * 指定最新的一次git提交的hash或HEAD(将包含)
     * @param $commit_id
     * @return $this
     */
    public function newCommit($commit_id): Git
    {
        $this->new_commit = $commit_id;
        return $this;
    }

    /**
     * 指定最之前一次git提交的hash或HEAD(将不包含)
     * @param $commit_id
     * @return $this
     */
    public function oldCommit($commit_id): Git
    {
        $this->old_commit = $commit_id;
        return $this;
    }

    /**
     * 全量打包时的分支名称
     * @param $branch_name
     * @return $this
     */
    public function branch($branch_name): Git
    {
        $this->branch = $branch_name;
        return $this;
    }

    public function prepare(): Git
    {
        $this->cmd .= 'git archive ';
        if ($this->branch) $this->cmd .= "$this->branch ";
        if ($this->output) $this->cmd .= "-o $this->dist$this->output ";
        if ($this->format) $this->cmd .= "--format=$this->format ";
        if (!empty($this->add_file)) {
            foreach ($this->add_file as $item) {
                $this->cmd .= "--add-file=$item ";
            }
        }
        if ($this->new_commit) $this->cmd .= "$this->new_commit ";

        $diff = '$(git diff --name-only %s %s)';

        if (($this->new_commit === 'HEAD' && !$this->old_commit) || ($this->new_commit === 'HEAD' && $this->old_commit === 'HEAD')) {
            $diff = sprintf($diff, 'HEAD', '');
        } elseif (($this->new_commit === 'HEAD' && $this->old_commit === 'HEAD^')) {
            $diff = sprintf($diff, 'HEAD^', '');
        } else {
            $diff = sprintf($diff, $this->old_commit, $this->new_commit);
        }
        if ($this->new_commit) $this->cmd .= $diff;

        $this->cmd = trim($this->cmd);
        return $this;
    }

    public function run(): string
    {
        if (!$this->cmd) $this->prepare();
        if (PHP_OS === 'WINNT') {
            logE('cmd not support, Please execute manually');
            logP($this->cmd);
            return '';
        }
        if (is_file($this->getOutPutFile())) unlink($this->getOutPutFile());
        return $this->execGit($this->cmd);
    }

    public function hashShort(): string
    {
        return $this->execGit($this->cmd_hash_short);
    }

    public function hashLong(): string
    {
        return $this->execGit($this->cmd_hash_long);
    }

    public function branchName(): string
    {
        return $this->execGit($this->cmd_branch_name);
    }

    public function objectName()
    {
        $rs = $this->execGit($this->cmd_name);
        $arr = explode('/', $rs);
        return $arr[count($arr) - 1];
    }

    public function execGit($cmd): string
    {
        return trim(shell_exec("$cmd 2>&1"));
    }
}

$git = new Git;
$object_name = strtoupper($git->objectName());
$add_other_file = false;

// 打包方式 1:全量打包(默认) 2:最近一次提交和当前未提交的文件 3:某两次提交的差异文件 4:当前已修改但未提交的文件
logI('Please select packaging method:');
logI('      [1]: Full packaging');
logI('      [2]: Packaging Last commit and current Not commit files');
logI('      [3]: Packaging Two commits different files');
logI('      [4]: Packaging Current Not commit files');
logI('Your choice (default [1]):', false);
choice:
$choice = trim(fgets(STDIN));
$time = date('md');
$last_hash = strtoupper($git->hashShort());
switch ($choice) {
    case 2:
        $file = "{$object_name}_LAST_UPDATE_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('HEAD')->oldCommit('HEAD^')->run();
        if ($rs) {
            logI($rs);
            logP('Generated File: ' . $file);
        }
        exit(0);
    case 4:
        $file = "{$object_name}_LAST_COMMIT_{$time}_$last_hash.tar.gz";
        $rs = $git->output($file)->newCommit('HEAD')->run();
        if ($rs) {
            logI($rs);
            logP('Generated File: ' . $file);
        }
        exit(0);
    case 3:
        logI('Please enter new commit id:', false);
        $new = trim(fgets(STDIN));
        $_new = strtoupper($new);
        logI('Please enter old commit id:', false);
        $old = trim(fgets(STDIN));
        $_old = strtoupper($old);
        $file = "{$object_name}_UPDATE_{$time}_{$_new}_$_old.tar.gz";
        $rs = $git->output($file)->newCommit($new)->oldCommit($old)->run();
        if ($rs) {
            logI($rs);
            logP('Generated File: ' . $file);
        }
        exit(0);
    case 1:
    case '':
        break;
    default:
        logE('Your input is incorrect, please re-enter');
        goto choice;
}

$ini = new Ini(dirname(__FILE__) . '/dist/version.ini');

$vv = $ini->get('version') ? function () use ($ini) {
    $arr = explode('.', $ini->get('version'));
    return "$arr[0].$arr[1].";
} : 'V1.0.';
// 注意: 如需更改大版本 如: V1.0 -> V2.1 需手动更改./dist/version.ini中version字段大版本
$version = [
    'author' => 'DM',
    'version' => $vv . date('md') . '.' . strtoupper($git->hashShort()),
    'git_branch_name' => $git->branchName(),
    'git_version_hash_short' => $git->hashShort(),
    'git_version_hash_long' => $git->hashLong(),
    'update_time' => date('Y-m-d H:i:s'),
];

logI('Generate version...');
logI("Branch: {$version['git_branch_name']}");
logI("Version: {$version['version']}\r\n");

$ini->setAll($version);

logP('Packing vendor? (It will take a long time for y) (y/n) (default:n): ', false);
$answer = trim(fgets(STDIN));

logI("Begin packing...");

if ($answer == 'y') {
    $rs = $git->output("$object_name.{$version['version']}.tar")->addFile($version_file)->run();
    logI($rs);
    $pack_file = $git->getOutPutFile();
    $zippy = Zippy::load();
    logI("Begin packing vendor...");
    $archive = $zippy->open($pack_file);
    $archive->addMembers('vendor');
    $new_pack_file = $pack_file . '.gz';
    $zippy->create($new_pack_file, $pack_file);
    unlink($pack_file);
    logI('Packing vendor finished');
} else {
    $rs = $git->branch($git->branchName())->output("$object_name.{$version['version']}.tar.gz")->addFile($version_file)->run();
    logI($rs);
    $new_pack_file = $git->getOutPutFile();
}

logI("Packing finished");

logP('Generated File: ' . $new_pack_file);
